import React from 'react';
import MathRenderer from './MathRenderer';
import { marked } from 'marked';

interface MathTextProps {
  children: string;
  className?: string;
}

/**
 * Component that renders text with markdown formatting and basic math expressions
 *
 * CRITICAL RENDERING BEHAVIOR:
 * - Uses 'marked' library for markdown parsing
 * - Processes LaTeX math expressions separately to prevent markdown interference
 * - breaks: false is ESSENTIAL to prevent unwanted line breaks in inline math
 *
 * COMMON ISSUE: Why breaks: false?
 * - With breaks: true, marked converts single newlines to <br> tags
 * - This causes LaTeX expressions like "$38^{\circ}$" to break onto new lines
 * - Result: "38¬∞" appears on a separate line from surrounding text
 * - Setting breaks: false keeps inline math on the same line as surrounding text
 *
 * HOW IT WORKS:
 * 1. Extract math segments ($...$, $$...$$) and replace with placeholders
 * 2. Parse remaining text with marked (respecting block vs inline markdown)
 * 3. Replace placeholders with rendered KaTeX components
 *
 * DO NOT change breaks to true without testing inline LaTeX thoroughly!
 */
const MathText: React.FC<MathTextProps> = ({ children, className = '' }) => {
  // Configure marked for rendering
  // breaks: false prevents single newlines from becoming <br> tags
  // This is critical for proper inline math rendering
  marked.setOptions({
    breaks: false, // DO NOT set to true - breaks inline LaTeX rendering
    gfm: true,
  });

  // Step 1: Extract math segments and replace with unique placeholders
  const segments = processTextWithBasicMath(children);
  const mathSegments: Array<{ content: string; inline: boolean }> = [];
  let textWithPlaceholders = '';

  segments.forEach((segment) => {
    if (segment.type === 'math') {
      const index = mathSegments.length;
      // Store both content and inline flag
      mathSegments.push({
        content: segment.content,
        inline: segment.inline !== false // Default to inline if not specified
      });
      // Use a unique marker that won't be modified by marked
      textWithPlaceholders += `‚ü®‚ü®MATH${index}‚ü©‚ü©`;
    } else {
      textWithPlaceholders += segment.content;
    }
  });

  // Step 2: Detect if content has block-level markdown
  // IMPORTANT: This detection should be CONSERVATIVE to avoid unnecessary block parsing
  //
  // WHY CONSERVATIVE?
  // - Block parsing (marked.parse) wraps content in <p> tags and can create unwanted spacing
  // - Inline parsing (marked.parseInline) keeps content flowing naturally
  // - Double newlines (\n\n) alone don't always mean we need block parsing
  //
  // WHEN TO USE BLOCK PARSING:
  // - Headers (###, ##, #)
  // - Lists (\n- or \n*)
  // - Multiple distinct paragraphs with meaningful separation
  //
  // REMOVED: textWithPlaceholders.includes('\n\n')
  // - This was too aggressive and caused inline math to render as block elements
  // - Now we only use block parsing when there's actual block-level markdown syntax
  const hasBlockMarkdown = textWithPlaceholders.includes('###') ||
                          textWithPlaceholders.includes('##') ||
                          (textWithPlaceholders.includes('#') && textWithPlaceholders.match(/^#+ /m)) ||
                          textWithPlaceholders.includes('\n- ') ||
                          textWithPlaceholders.includes('\n* ');

  // DEBUG LOGGING: Keep for troubleshooting LaTeX/markdown rendering issues
  // WHEN TO USE: When investigating "extra line breaks" or "LaTeX on separate lines" bugs
  // WHAT IT SHOWS:
  //   - originalText: Input before processing (first 200 chars)
  //   - textWithPlaceholders: Text after LaTeX extraction (shows ‚ü®‚ü®MATH0‚ü©‚ü© placeholders)
  //   - mathSegments: Number of LaTeX expressions found
  //   - hasBlockMarkdown: Whether block parsing was triggered (lists, headers, etc.)
  // HOW TO READ: If list items like "* Length = $15\text{ cm}$" show up, you'll see
  //              textWithPlaceholders as "* Length = ‚ü®‚ü®MATH0‚ü©‚ü©" which triggers block mode.
  if (hasBlockMarkdown) {
    //console.log('üîç MathText block markdown detected:', {
     // originalText: children.substring(0, 200),
      //textWithPlaceholders: textWithPlaceholders.substring(0, 200),
      //mathSegments: mathSegments.length,
      //hasBlockMarkdown
   // });
  }

  // Step 3: Render markdown with placeholders
  // Note: marked.parse() returns string synchronously in this version
  const renderedHtml = hasBlockMarkdown
    ? (marked.parse(textWithPlaceholders) as string)
    : (marked.parseInline(textWithPlaceholders) as string);

  // DEBUG LOGGING: Shows the HTML generated by marked.parse()
  // WHEN TO USE: When investigating how markdown lists are being converted to HTML
  // WHAT IT SHOWS:
  //   - renderedHtml: The HTML output from marked (first 300 chars)
  //   - Shows if LaTeX placeholders are inside <li> tags: "<li>Length = ‚ü®‚ü®MATH0‚ü©‚ü©</li>"
  // HOW TO FIX: If you see LaTeX in <li> tags causing line breaks, the CSS fix in
  //             index.css (.math-text-with-lists) should handle it. If not, check that
  //             the className is being applied (see line 141).
  /*
  if (hasBlockMarkdown) {
    console.log('üîç MathText rendered HTML:', {
      renderedHtml: renderedHtml.substring(0, 300),
      fullHtmlLength: renderedHtml.length
    });
  }*/

  // Step 4: Split HTML by math placeholders and render
  const parts = renderedHtml.split(/(‚ü®‚ü®MATH\d+‚ü©‚ü©)/);

  // CRITICAL FIX FOR LIST RENDERING WITH LATEX (Added: January 2025)
  //
  // PROBLEM: When markdown lists contain LaTeX math (e.g., "* Length = $15\text{ cm}$"),
  // the marked.parse() function converts them to HTML <li> elements:
  //   Input:  * Length (AB) = $15\text{ cm}$
  //   Output: <li>Length (AB) = ‚ü®‚ü®MATH0‚ü©‚ü©</li>
  //
  // Browser default <li> styling causes:
  //   - display: list-item (forces line break before/after)
  //   - Extra margin/padding between items
  //   - Result: LaTeX math appearing on separate line from text
  //
  // VISUAL BUG EXAMPLE:
  //   ‚Ä¢ Length (AB) =
  //     15 cm              ‚Üê LaTeX on new line (BAD)
  //
  // SOLUTION: Apply 'math-text-with-lists' class when block markdown is detected.
  // This class (defined in index.css) provides compact list styling that keeps
  // LaTeX math inline with text while maintaining readability.
  //
  // WHY NOT use parseInline()?
  // - We need proper <ul>/<li> structure for accessibility and semantic HTML
  // - The fix belongs in CSS presentation layer, not parsing logic
  //
  // DEBUGGING: Look for "üîç MathText block markdown detected" in console to verify
  // list detection and see the HTML output.
  //
  // TEST CASE: "* Length = $15\text{ cm}$\n* Width = $10\text{ m}$"
  // Should render as compact list with math inline, not separate lines.
  const WrapperElement = hasBlockMarkdown ? 'div' : 'span';

  return (
    <WrapperElement className={`${className} ${hasBlockMarkdown ? 'math-text-with-lists' : ''}`}>
      {parts.map((part: string, index: number) => {
        // Check if this part is a math placeholder
        const mathMatch = part.match(/^‚ü®‚ü®MATH(\d+)‚ü©‚ü©$/);
        if (mathMatch) {
          const mathIndex = parseInt(mathMatch[1]);
          const mathSegment = mathSegments[mathIndex];
          return (
            <MathRenderer key={index} inline={mathSegment.inline}>
              {mathSegment.content}
            </MathRenderer>
          );
        }
        // Render HTML part
        return <span key={index} dangerouslySetInnerHTML={{ __html: part }} />;
      })}
    </WrapperElement>
  );
};

interface TextSegment {
  type: 'text' | 'math';
  content: string;
  inline?: boolean; // For math segments: true = inline ($...$), false = display ($$...$$)
}

/**
 * Smart detection: LaTeX (with or without $) ‚Üí Plain fractions ‚Üí Plain text
 * Handles: $\frac{1}{3}$ (delimited LaTeX), 4 \div 1/3 (bare LaTeX), 1/2 (plain), $3.50 (money)
 *
 * PROCESSING ORDER (CRITICAL - DO NOT CHANGE):
 * 1. Display math ($$...$$) - processed FIRST to avoid conflicts with inline math
 * 2. Inline math ($...$) - must contain backslash to avoid matching money ($3.50)
 * 3. Bare LaTeX (\div, \times, \frac{}{}) - without $ delimiters
 * 4. Plain fractions (1/2, 3/4) - converted to \frac{}{} automatically
 *
 * WHY THIS ORDER?
 * - Display math first prevents $$ from being split into two $ markers
 * - Inline math before bare LaTeX captures delimited expressions first
 * - Bare LaTeX before fractions handles mathematical operators
 * - Plain fractions last for simple numeric ratios
 */
function processTextWithBasicMath(text: string): TextSegment[] {
  // Safety check for undefined/null text
  if (!text || typeof text !== 'string') {
    return [{ type: 'text', content: '' }];
  }

  const segments: TextSegment[] = [];
  let workingText = text;
  let currentIndex = 0;

  // Step 1a: Detect display math $$...$$ (process these first to avoid conflicts with single $)
  // Matches: $$\frac{x}{y}$$, $$E = mc^2$$, etc.
  //
  // DISPLAY vs INLINE MATH:
  // - Display math ($$...$$): Centered on its own line, larger size, used for important equations
  // - Inline math ($...$): Flows with text, same line, used for variables and small expressions
  //
  // PATTERN EXPLANATION: /\$\$([^$]+)\$\$/g
  // - \$\$ = literal "$$" (escaped because $ is a regex special char)
  // - ([^$]+) = capture one or more characters that are NOT "$" (the math content)
  // - \$\$ = closing "$$"
  // - g flag = find all matches globally
  const displayMathPattern = /\$\$([^$]+)\$\$/g;
  let displayMatch: RegExpExecArray | null;

  while ((displayMatch = displayMathPattern.exec(workingText)) !== null) {
    const matchStart = displayMatch.index;
    const matchEnd = matchStart + displayMatch[0].length;

    // Add text before display math
    if (matchStart > currentIndex) {
      const textBefore = workingText.substring(currentIndex, matchStart);
      segments.push(...processInlineMathAndFractions(textBefore));
    }

    // Add display math (capture group 1 already stripped $$ delimiters)
    const mathContent = displayMatch[1].trim();
    segments.push({ type: 'math', content: mathContent, inline: false });

    currentIndex = matchEnd;
  }

  // Step 1b: Detect inline LaTeX notation $...$ (must contain backslash to avoid matching money)
  // Only process remaining text that hasn't been consumed by display math
  if (currentIndex < workingText.length) {
    const remainingText = workingText.substring(currentIndex);
    segments.push(...processInlineMathAndFractions(remainingText));
  }

  // If no math found, ensure we have at least one segment
  if (segments.length === 0) {
    segments.push({ type: 'text', content: text });
  }

  return segments;
}

/**
 * Process inline math $...$ and bare LaTeX commands and plain fractions
 * Handles: $\theta$, 4 \div 1/3, \times, \frac{1}{2}, 1/2, etc.
 *
 * INLINE MATH PATTERN: /\$([^$]*\\[^$]*)\$/g
 * - This pattern REQUIRES a backslash inside the $ delimiters
 * - WHY? To avoid matching money amounts like $3.50 or $100
 * - Examples that MATCH: $x$ ‚ùå (no backslash), $\theta$ ‚úì, $38^{\circ}$ ‚úì
 *
 * WAIT - THIS IS A BUG!
 * The pattern requires a backslash, so $x$ doesn't match as inline math.
 * This might explain why $x$ is being rendered incorrectly.
 * However, changing this could break money amount detection.
 *
 * BETTER APPROACH: Use word boundaries and context to distinguish math from money
 */
function processInlineMathAndFractions(text: string): TextSegment[] {
  const segments: TextSegment[] = [];
  let currentIndex = 0;

  // First, detect inline math $...$
  // UPDATED PATTERN: Now matches $x$ as well as $\theta$ and $38^{\circ}$
  //
  // OLD PATTERN (BUGGY): /\$([^$]*\\[^$]*)\$/g - required backslash
  // - This missed simple variables like $x$, $y$, $n$
  // - Caused $x$ to be rendered as plain text with $ signs
  //
  // NEW PATTERN: /\$([^$]+)\$/g
  // - Matches ANY content between $ delimiters (except nested $)
  // - Much simpler and catches all LaTeX: $x$, $\theta$, $38^{\circ}$, $\frac{1}{2}$ ‚úì
  //
  // MONEY DETECTION CONCERN:
  // - This WILL match money like $3.50 and $100
  // - TRADE-OFF: We prioritize math rendering over money detection
  // - If money needs to be displayed, write it as: "USD 3.50" or "3.50 dollars"
  // - OR escape it: \$3.50 (backslash before $)
  //
  // EXAMPLES:
  // - $x$ ‚úì (simple variable)
  // - $38^{\circ}$ ‚úì (superscript with symbol)
  // - $\frac{1}{2}$ ‚úì (fraction)
  // - $3.50 ‚úì (will be rendered as math, which is probably wrong for money)
  // - $100 ‚úì (will be rendered as math)
  //
  // WHY THIS IS OK:
  // - Educational math content rarely uses $ for money
  // - LaTeX rendering of numbers ($100$) looks fine anyway
  // - Simpler pattern = fewer bugs = better UX
  const inlineMathPattern = /\$([^$]+)\$/g;
  let inlineMatch: RegExpExecArray | null;

  while ((inlineMatch = inlineMathPattern.exec(text)) !== null) {
    const matchStart = inlineMatch.index;
    const matchEnd = matchStart + inlineMatch[0].length;

    // Add text before inline math
    if (matchStart > currentIndex) {
      const textBefore = text.substring(currentIndex, matchStart);
      segments.push(...processBareLatexAndFractions(textBefore));
    }

    // Add inline math (capture group 1 already stripped $ delimiters)
    const mathContent = inlineMatch[1];
    segments.push({ type: 'math', content: mathContent, inline: true });

    currentIndex = matchEnd;
  }

  // Add remaining text (process for bare LaTeX and fractions)
  if (currentIndex < text.length) {
    const remainingText = text.substring(currentIndex);
    segments.push(...processBareLatexAndFractions(remainingText));
  }

  // If no inline math found, just process as bare LaTeX and fractions
  if (segments.length === 0) {
    return processBareLatexAndFractions(text);
  }

  return segments;
}

/**
 * Process bare LaTeX commands (without $ delimiters) and plain fractions
 * Handles: 4 \div 1/3, \times, \frac{1}{2}, etc.
 */
function processBareLatexAndFractions(text: string): TextSegment[] {
  const segments: TextSegment[] = [];

  // Detect bare LaTeX commands: \div, \times, \frac{}{}, etc.
  // Match from first backslash to either next backslash or end of math expression
  const bareLatexPattern = /\\[a-zA-Z]+(?:\{[^}]*\}\{[^}]*\})?/g;

  let currentIndex = 0;
  let match: RegExpExecArray | null;

  while ((match = bareLatexPattern.exec(text)) !== null) {
    // Add text before the LaTeX command (may contain plain fractions)
    if (match.index > currentIndex) {
      const textBefore = text.substring(currentIndex, match.index);
      segments.push(...processPlainFractions(textBefore));
    }

    // Add the LaTeX command as math
    segments.push({ type: 'math', content: match[0] });

    currentIndex = match.index + match[0].length;
  }

  // Add remaining text (may contain plain fractions)
  if (currentIndex < text.length) {
    const remainingText = text.substring(currentIndex);
    segments.push(...processPlainFractions(remainingText));
  }

  // If no LaTeX found, just process as plain fractions
  if (segments.length === 0) {
    return processPlainFractions(text);
  }

  return segments;
}

/**
 * Step 2: Process plain fractions like 1/2, 3/4 (no LaTeX delimiters)
 */
function processPlainFractions(text: string): TextSegment[] {
  const segments: TextSegment[] = [];
  const simpleFractionPattern = /(\b\d+\/\d+\b)/g;

  let lastIndex = 0;
  let match: RegExpExecArray | null;

  while ((match = simpleFractionPattern.exec(text)) !== null) {
    // Add text before the fraction
    if (match.index > lastIndex) {
      const textBefore = text.substring(lastIndex, match.index);
      if (textBefore) {
        segments.push({ type: 'text', content: textBefore });
      }
    }

    // Convert plain fraction to LaTeX and add as math
    const fraction = match[1];
    const latex = fraction.replace(/(\d+)\/(\d+)/, '\\frac{$1}{$2}');
    segments.push({ type: 'math', content: latex });

    lastIndex = match.index + match[1].length;
  }

  // Add remaining text
  if (lastIndex < text.length) {
    const remainingText = text.substring(lastIndex);
    if (remainingText) {
      segments.push({ type: 'text', content: remainingText });
    }
  }

  // If no fractions found, return the text as-is
  if (segments.length === 0) {
    segments.push({ type: 'text', content: text });
  }

  return segments;
}

export default MathText;